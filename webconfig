#!/usr/bin/env ruby
# -*- ruby -*-

# Copyright 2009 Burke Libbey / Chromium 53. Released under MIT License.

$LOAD_PATH << File.join(File.dirname(__FILE__),'lib')

begin
  require 'rubygems'
rescue LoadError
end
require 'yaml'

# No syntax checking whatsoever on the yaml files. You're on your own.

module Webconfig

  WEBCONFIG_PATH = File.dirname(__FILE__)
  CONFIG_PATH    = File.join(WEBCONFIG_PATH,'config')
  DEFAULTS       = YAML.load_file("#{CONFIG_PATH}/defaults.yml")
  TEMPLATES      = YAML.load_file("#{CONFIG_PATH}/templates.yml")
  DOMAINS        = YAML.load_file("#{CONFIG_PATH}/config.yml")
  # Get a list of the different servers templates.yml specifies configs for.
  # example: ["nginx", "apache"]
  SERVERS = TEMPLATES.values.map(&:keys).flatten.uniq.map{|s|s.gsub('content_for_','')}

  # Return a hash of configuration files by server. Eg. {"apache" => "<VirtualHost *>........"}
  def self.config_by_server
    SERVERS.inject({}) do |hash, server|
      hash.merge!({server => config_for_server(server)})
    end
  end
  
  def self.config_for_server(server)
    relevant_templates = TEMPLATES.reject{|k,v| ! v.has_key?("content_for_#{server}")}
    output = ""
    
    # Each domain of a template type that specifies configuration for this server
    relevant_domains = DOMAINS.reject do |domain, args|
      ! relevant_templates.keys.include?(args['template'])
    end

    relevant_domains.inject("") do |output, domain|
      # Add the domain name (hash key) to the args (hash value)
      domaininfo = domain[1].merge({"domain" => domain[0]})
      output << Domain.new(domaininfo).content_for_server(server)
    end

  end

  def self.test_and_load_config(server)
    srv_mod_name = "#{server.capitalize}Server"
    unless Object.const_defined?(srv_mod_name)
      begin
        require "servers/#{server}"
      rescue LoadError
        puts "*** DON'T KNOW HOW TO CHECK AND LOAD SERVER: #{server} ***"
        puts " ** YOU'LL HAVE TO RESTART IT MANUALLY."
        return
      end
    end
    srv_mod = Object.const_get(srv_mod_name)
    unless srv_mod::config_ok?
      puts "*** CONFIG CHECK FAILED FOR SERVER: #{server} ***"
    else
      unless srv_mod::reload
        puts "*** RELOAD SEEMS TO HAVE FAILED FOR SERVER #{server}. ***"
      end
    end
  end
    
  class Domain

    def initialize(args)
      # This might be dangerous? I'm pretty sure we can trust whomever's
      # writing our vhost definitions :)
      args = DEFAULTS.merge args
      args.each do |k,v|
        instance_variable_set "@#{k}", v
      end

      # We need to wrap @location in slashes, but if it's root, that gives us
      #   // or ///, so we collapse multiple sequential slashes to a single /.
      @location = "/#{@location}/"
      @location.gsub!(/\/+/,'/')
    end

    def content_for_server(server)
      cfs = "content_for_#{server}"
      begin
       eval("return <<-\"SOMEUNUSUALTOKEN_END\"

#{Webconfig::TEMPLATES[@template][cfs]}

        SOMEUNUSUALTOKEN_END")
      rescue
        raise SyntaxError, "Invalid syntax in configuration files. Failed parsing #{domain}."
      end
    end
  end
end


if __FILE__ == $0

  puts "Building configuration..."

  config = Webconfig.config_by_server

  # Write out a file in ./gen for each server configured. 
  config.each do |server, config|
    File.open("#{Webconfig::WEBCONFIG_PATH}/gen/#{server}.gen.conf",'w') do |f|
      f.puts config
    end
    Webconfig.test_and_load_config(server)
  end

  puts "[success]"
  
end
